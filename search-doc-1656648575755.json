[{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal&lt;any&gt; Fires when the property receives an updated value from the server. clientRemoteProperty.Changed:Connect(function(value) print(&quot;New value&quot;, value) end)  "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#functions","content":" "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Gets the value of the property object. caution This value might not be ready right away. Use OnReady() or IsReady() before calling Get(). If not ready, this value will return nil.  "},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty:OnReady() → Promise&lt;any&gt; Returns a Promise which resolves once the property object is ready to be used. The resolved promise will also contain the value of the property. -- Use andThen clause: clientRemoteProperty:OnReady():andThen(function(initialValue) print(initialValue) end) -- Use await: local success, initialValue = clientRemoteProperty:OnReady():await() if success then print(initialValue) end   "},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty:IsReady() → boolean Returns true if the property object is ready to be used. In other words, it has successfully gained connection to the server-side version and has synced in the initial value. if clientRemoteProperty:IsReady() then local value = clientRemoteProperty:Get() end   "},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty:Observe(observer: (any) → nil) → Connection Observes the value of the property. The observer will be called right when the value is first ready, and every time the value changes. This is safe to call immediately (i.e. no need to use IsReady or OnReady before using this method). Observing is essentially listening to Changed, but also sends the initial value right away (or at least once OnReady is completed). local function ObserveValue(value) print(value) end clientRemoteProperty:Observe(ObserveValue)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the ClientRemoteProperty object. "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"api/ClientRemoteSignal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → ()) → Connection "},{"title":"Types","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal##","content":""},{"title":"​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Connection","content":"interface Connection { Disconnect: () → () }  Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object. "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"api/RemoteProperty","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the top-level value of all clients to the same value. Override Per-Player Data This will override any per-player data that was set usingSetFor or SetFilter. To avoid overriding this data, SetTop can be used instead. -- Examples remoteProperty:Set(10) remoteProperty:Set({SomeData = 32}) remoteProperty:Set(&quot;HelloWorld&quot;)   "},{"title":"SetTop​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#SetTop","content":"&lt;/&gt; RemoteProperty:SetTop(value: any) → () Set the top-level value of the property, but does not override any per-player data (e.g. set with SetFor or SetFilter). Any player without custom-set data will receive this new data. This is useful if certain players have specific values that should not be changed, but all other players should receive the same new value. -- Using just 'Set' overrides per-player data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Using 'SetTop' does not override: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot;   "},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#SetFilter","content":"&lt;/&gt; RemoteProperty:SetFilter( predicate: ( Player , any ) → boolean, value: any-- Value to set for the clients (and to the predicate) ) → () Sets the value for specific clients that pass the predicate function test. This can be used to finely set the values based on more control logic (e.g. setting certain values per team). -- Set the value of &quot;NewValue&quot; to players with a name longer than 10 characters: remoteProperty:SetFilter(function(player) return #player.Name &gt; 10 end, &quot;NewValue&quot;)   "},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#SetFor","content":"&lt;/&gt; RemoteProperty:SetFor( player: Player , value: any ) → () Set the value of the property for a specific player. This will override the value used by Set (and the initial value set for the property when created). This value can be nil. In order to reset the value for a given player and let the player use the top-level value held by this property, either use Set to set all players' data, or use ClearFor. remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;)   "},{"title":"SetForList​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#SetForList","content":"&lt;/&gt; RemoteProperty:SetForList( players: {Player }, value: any ) → () Set the value of the property for specific players. This just loops through the players given and calls SetFor. local players = {player1, player2, player3} remoteProperty:SetForList(players, &quot;CustomData&quot;)   "},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#ClearFor","content":"&lt;/&gt; RemoteProperty:ClearFor(player: Player ) → () Clears the custom property value for the given player. When this occurs, the player will reset to use the top-level value held by this property (either the value set when the property was created, or the last value set by Set). remoteProperty:Set(&quot;DATA&quot;) remoteProperty:SetFor(somePlayer, &quot;CUSTOM_DATA&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CUSTOM_DATA&quot; -- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL: remoteProperty:SetFor(somePlayer, nil) print(remoteProperty:GetFor(somePlayer)) --&gt; nil -- CLEAR: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;DATA&quot;   "},{"title":"ClearForList​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#ClearForList","content":"&lt;/&gt; RemoteProperty:ClearForList(players: {Player }) → () Clears the custom value for the given players. This just loops through the list of players and calls the ClearFor method for each player.  "},{"title":"ClearFilter​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#ClearFilter","content":"&lt;/&gt; RemoteProperty:ClearFilter(predicate: (Player ) → boolean) → () The same as SetFiler, except clears the custom value for any player that passes the predicate.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → any Returns the top-level value held by the property. This will either be the initial value set, or the last value set with Set(). remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:Get()) --&gt; &quot;Data&quot;   "},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#GetFor","content":"&lt;/&gt; RemoteProperty:GetFor(player: Player ) → any Returns the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). -- Set top level data: remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Set custom data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Set top level again, overriding custom data: remoteProperty:Set(&quot;NewData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;NewData&quot; -- Set custom data again, and set top level without overriding: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Clear custom data to use top level data: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot;   "},{"title":"Observe​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Observe","content":"&lt;/&gt; RemoteProperty:Observe(observer: (any) → nil) → Connection Observes the &quot;top&quot; value of the property. The observer will be called right with the initial value, and every time the value changes. local function ObserveValue(value) print(value) end remoteProperty:Observe(ObserveValue)   "},{"title":"ObserveFor​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#ObserveFor","content":"&lt;/&gt; RemoteProperty:ObserveFor( player: Player , observer: (any) → nil ) → Connection Observes the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). local function ObserveValue(value) print(value) end remoteProperty:ObserveFor(player, ObserveValue)   "},{"title":"ObserveAll​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#ObserveAll","content":"&lt;/&gt; RemoteProperty:ObserveAll(observer: ( Player , any ) → nil) → Connection Observes the current value for all players. This value for will depend on if SetFor or SetFilter has affected the custom value for each player. If so, that custom value will be used. Otherwise, the top-level value will be used (e.g. value from Set). local function ObservePlayerValue(player, value) print(player, value) end remoteProperty:ObserveAll(ObservePlayerValue)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the RemoteProperty object. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"api/RemoteSignal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player , ...: any ) → nil-- The function to connect ) → Connection "},{"title":"Types","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal##","content":""},{"title":"​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Connection","content":"interface Connection { Disconnect: () → nil Connected: boolean }  Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireExcept","content":"&lt;/&gt; RemoteSignal:FireExcept( ignorePlayer: Player ,-- The client to ignore ...: any-- Arguments passed to the other clients ) → () Fires the signal to all clients except the specified client. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireFor","content":"&lt;/&gt; RemoteSignal:FireFor( players: {Player }, ...: any ) → () Fires a signal at the clients within the players table. This is useful when signals need to fire for a specific set of players. For more complex firing, see FireFilter. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. local players = {somePlayer1, somePlayer2, somePlayer3} remoteSignal:FireFor(players, &quot;Hello, players!&quot;)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object. "},{"title":"Repl","type":0,"sectionRef":"#","url":"api/Repl","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Repl","url":"api/Repl#properties","content":" "},{"title":"ServerRepl​","type":1,"pageTitle":"Repl","url":"api/Repl#ServerRepl","content":"&lt;/&gt; Repl.ServerRepl: ServerRepl   "},{"title":"ClientRepl​","type":1,"pageTitle":"Repl","url":"api/Repl#ClientRepl","content":"&lt;/&gt; Repl.ClientRepl: ClientRepl  "},{"title":"ServerRepl","type":0,"sectionRef":"#","url":"api/ServerRepl","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#types","content":" "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#new","content":"&lt;/&gt; ServerRepl.new( parent: Instance , namespace: string? ) → ServerRepl Constructs a ServerRepl object. The namespace parameter is used in cases where more than one ServerRepl object may be bound to the same object. Otherwise, a default namespace is used. local serverRepl = ServerRepl.new(game:GetService(&quot;ReplicatedStorage&quot;)) -- If many might exist in the given parent, use a unique namespace: local serverRepl = ServerRepl.new(game:GetService(&quot;ReplicatedStorage&quot;), &quot;MyNamespace&quot;)   "},{"title":"BindFunction​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#BindFunction","content":"&lt;/&gt; ServerRepl:BindFunction( name: string, fn: ( player: Player , ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired. local function GetSomething(player: Player) return &quot;Something&quot; end serverRepl:BindFunction(&quot;GetSomething&quot;, GetSomething)   "},{"title":"WrapMethod​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#WrapMethod","content":"&lt;/&gt; ServerRepl:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Binds a function to a table method. The name must match the name of the method in the table. The same name will be used on the client to access the given function. local MyObject = { _Data = 10, } function MyObject:GetData(player: Player) return self._Data end serverRepl:WrapMethod(MyObject, &quot;GetData&quot;)   "},{"title":"CreateSignal​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#CreateSignal","content":"&lt;/&gt; ServerRepl:CreateSignal( name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal Creates a signal that can be used to fire data to the clients or receive data from the clients. local mySignal = serverRepl:CreateSignal(&quot;MySignal&quot;) -- Examples of firing in different ways (see docs for RemoteSignal for further info): mySignal:Fire(somePlayer, &quot;Hello world&quot;) mySignal:FireAll(&quot;Hi there&quot;) mySignal:FireExcept(somePlayer, &quot;Hello everyone except &quot; .. somePlayer.Name) mySignal:FireFilter(function(player) return player.Team == someCoolTeam end, &quot;Hello cool team&quot;) -- Example of listening for clients to send data: mySignal:Connect(function(player, message) print(&quot;Got a message from &quot; .. player.Name .. &quot;:&quot;, message) end)   "},{"title":"CreateProperty​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#CreateProperty","content":"&lt;/&gt; ServerRepl:CreateProperty( name: string, initialValue: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteProperty Create a property object which will replicate its property value to the clients. Optionally, specific clients can be targeted with different property values. local repl = Repl.ServerRepl.new(game:GetService(&quot;ReplicatedStorage&quot;)) local mapInfo = repl:CreateProperty(&quot;MapInfo&quot;, { MapName = &quot;TheAwesomeMap&quot;, MapDuration = 60, }) -- Change the data: mapInfo:Set({ MapName = &quot;AnotherMap&quot;, MapDuration = 30, }) -- Change the data for one player: mapInfo:SetFor(somePlayer, { MapName = &quot;ASpecialMapForYou&quot;, MapDuration = 90, }) -- Change data based on a predicate function: mapInfo:SetFilter(function(player) return player.Team == game.Teams.SomeSpecialTeam end, { MapName = &quot;TeamMap&quot;, MapDuration = 20, })   "},{"title":"Destroy​","type":1,"pageTitle":"ServerRepl","url":"api/ServerRepl#Destroy","content":"&lt;/&gt; ServerRepl:Destroy() → () Destroy the ServerRepl object. "},{"title":"ClientRepl","type":0,"sectionRef":"#","url":"api/ClientRepl","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#types","content":" "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#new","content":"&lt;/&gt; ClientRepl.new( parent: Instance , usePromise: boolean, namespace: string? ) → ClientRepl Constructs a ClientRepl object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds. local clientRepl = ClientRepl.new(game:GetService(&quot;ReplicatedStorage&quot;), true) -- If using a unique namespace with ServerRepl, include it as second argument: local clientRepl = ClientRepl.new(game:GetService(&quot;ReplicatedStorage&quot;), true, &quot;MyNamespace&quot;)   "},{"title":"GetFunction​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#GetFunction","content":"&lt;/&gt; ClientRepl:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerRepl. The function can then be called to invoke the server. If this ClientRepl object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverRepl = ServerRepl.new(someParent) serverRepl:BindFunction(&quot;MyFunction&quot;, function(player, msg) return msg:upper() end) -- Client-side: local clientRepl = ClientRepl.new(someParent) local myFunc = clientRepl:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientRepl = ClientRepl.new(someParent, true) local myFunc = clientRepl:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#GetSignal","content":"&lt;/&gt; ClientRepl:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerRepl with the same matching name. local mySignal = clientRepl:GetSignal(&quot;MySignal&quot;) -- Listen for data from the server: mySignal:Connect(function(message) print(&quot;Received message from server:&quot;, message) end) -- Send data to the server: mySignal:Fire(&quot;Hello!&quot;)   "},{"title":"GetProperty​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#GetProperty","content":"&lt;/&gt; ClientRepl:GetProperty( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteProperty Returns a new ClientRemoteProperty that mirrors the matching RemoteProperty created by ServerRepl with the same matching name. Take a look at the ClientRemoteProperty documentation for more info, such as understanding how to wait for data to be ready. local mapInfo = clientRepl:GetProperty(&quot;MapInfo&quot;) -- Observe the initial value of mapInfo, and all subsequent changes: mapInfo:Observe(function(info) print(&quot;Current map info&quot;, info) end) -- Check to see if data is initially ready: if mapInfo:IsReady() then -- Get the data: local info = mapInfo:Get() end -- Get a promise that resolves once the data is ready (resolves immediately if already ready): mapInfo:OnReady():andThen(function(info) print(&quot;Map info is ready with info&quot;, info) end) -- Same as above, but yields thread: local success, info = mapInfo:OnReady():await()   "},{"title":"BuildObject​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#BuildObject","content":"&lt;/&gt; ClientRepl:BuildObject( inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → table Returns an object which maps RemoteFunctions as methods and RemoteEvents as fields. -- Server-side: serverRepl:BindFunction(&quot;Test&quot;, function(player) end) serverRepl:CreateSignal(&quot;MySignal&quot;) serverRepl:CreateProperty(&quot;MyProperty&quot;, 10) -- Client-side local obj = clientRepl:BuildObject() obj:Test() obj.MySignal:Connect(function(data) end) obj.MyProperty:Observe(function(value) end)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientRepl","url":"api/ClientRepl#Destroy","content":"&lt;/&gt; ClientRepl:Destroy() → () Destroys the ClientRepl object. "}]